{
  "version": 3,
  "sources": ["../src/server.ts", "../packages/mcp-config/src/config-manager.ts", "../packages/mcp-config/src/types.ts", "../packages/mcp-config/src/server.ts", "../packages/mcp-knowledge/src/server.ts", "../packages/mcp-knowledge/src/embeddings/local-embeddings.ts", "../packages/mcp-knowledge/src/processors/openapi.ts", "../packages/mcp-knowledge/src/sync.ts", "../packages/mcp-knowledge/src/scraper/crawler.ts", "../packages/mcp-knowledge/src/types.ts", "../packages/mcp-knowledge/src/processors/html.ts", "../packages/mcp-knowledge/src/processors/code.ts", "../packages/mcp-knowledge/src/processors/image.ts", "../packages/mcp-knowledge/src/paths.ts", "../packages/mcp-api/src/server.ts", "../packages/mcp-api/src/client.ts", "../packages/mcp-api/src/types.ts", "../packages/mcp-api/src/generator.ts"],
  "sourcesContent": ["import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { ConfigManager, registerConfigTools } from '@eduzz/mcp-config';\nimport { registerKnowledgeTools, setupKnowledgeCron, type KnowledgeServerConfig } from '@eduzz/mcp-knowledge';\nimport { registerAPITools } from '@eduzz/mcp-api';\n\nexport function createServer(): McpServer {\n  const server = new McpServer({\n    name: 'eduzz-devhub',\n    version: '2.0.0',\n  });\n\n  const configManager = new ConfigManager();\n\n  // Register all tools on a single server\n  registerConfigTools(server, configManager);\n\n  const knowledgeConfig: KnowledgeServerConfig = {};\n  registerKnowledgeTools(server, knowledgeConfig);\n\n  registerAPITools(server, { configManager });\n\n  // Start background cron for knowledge sync\n  setupKnowledgeCron(knowledgeConfig);\n\n  return server;\n}\n\nexport async function startServer(): Promise<void> {\n  const server = createServer();\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}\n", "import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { homedir } from 'node:os';\nimport { join } from 'node:path';\nimport {\n  Config,\n  ConfigSchema,\n  DEFAULT_CONFIG,\n  CONFIG_DIR,\n  CONFIG_FILE,\n  Profile,\n  ProfileInfo,\n  Environment,\n} from './types.js';\n\nexport class ConfigManager {\n  private configPath: string;\n  private config: Config;\n\n  constructor() {\n    const configDir = join(homedir(), CONFIG_DIR);\n    this.configPath = join(configDir, CONFIG_FILE);\n\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    this.config = this.loadConfig();\n  }\n\n  private loadConfig(): Config {\n    if (!existsSync(this.configPath)) {\n      this.saveConfig(DEFAULT_CONFIG);\n      return DEFAULT_CONFIG;\n    }\n\n    try {\n      const content = readFileSync(this.configPath, 'utf-8');\n      const parsed = JSON.parse(content);\n      return ConfigSchema.parse(parsed);\n    } catch {\n      return DEFAULT_CONFIG;\n    }\n  }\n\n  private saveConfig(config: Config): void {\n    writeFileSync(this.configPath, JSON.stringify(config, null, 2), 'utf-8');\n    this.config = config;\n  }\n\n  getConfigDir(): string {\n    return join(homedir(), CONFIG_DIR);\n  }\n\n  listProfiles(): ProfileInfo[] {\n    return Object.entries(this.config.profiles).map(([name, profile]) => ({\n      name,\n      environment: profile.environment,\n      isActive: this.config.active_profile === name,\n    }));\n  }\n\n  getActiveProfile(): { name: string; profile: Profile } | null {\n    if (!this.config.active_profile) {\n      return null;\n    }\n\n    const profile = this.config.profiles[this.config.active_profile];\n    if (!profile) {\n      return null;\n    }\n\n    return { name: this.config.active_profile, profile };\n  }\n\n  getProfile(name: string): Profile | null {\n    return this.config.profiles[name] || null;\n  }\n\n  createProfile(\n    name: string,\n    apiKey: string,\n    apiSecret: string,\n    environment: Environment\n  ): void {\n    if (this.config.profiles[name]) {\n      throw new Error(`Profile \"${name}\" already exists`);\n    }\n\n    const newConfig: Config = {\n      ...this.config,\n      profiles: {\n        ...this.config.profiles,\n        [name]: {\n          api_key: apiKey,\n          api_secret: apiSecret,\n          environment,\n        },\n      },\n    };\n\n    // If this is the first profile, make it active\n    if (!newConfig.active_profile) {\n      newConfig.active_profile = name;\n    }\n\n    this.saveConfig(newConfig);\n  }\n\n  updateProfile(\n    name: string,\n    updates: Partial<Profile>\n  ): void {\n    const existing = this.config.profiles[name];\n    if (!existing) {\n      throw new Error(`Profile \"${name}\" does not exist`);\n    }\n\n    const newConfig: Config = {\n      ...this.config,\n      profiles: {\n        ...this.config.profiles,\n        [name]: {\n          ...existing,\n          ...updates,\n        },\n      },\n    };\n\n    this.saveConfig(newConfig);\n  }\n\n  deleteProfile(name: string): void {\n    if (!this.config.profiles[name]) {\n      throw new Error(`Profile \"${name}\" does not exist`);\n    }\n\n    const { [name]: _, ...remainingProfiles } = this.config.profiles;\n\n    const newConfig: Config = {\n      ...this.config,\n      profiles: remainingProfiles,\n      active_profile:\n        this.config.active_profile === name\n          ? Object.keys(remainingProfiles)[0] || null\n          : this.config.active_profile,\n    };\n\n    this.saveConfig(newConfig);\n  }\n\n  switchProfile(name: string): void {\n    if (!this.config.profiles[name]) {\n      throw new Error(`Profile \"${name}\" does not exist`);\n    }\n\n    const newConfig: Config = {\n      ...this.config,\n      active_profile: name,\n    };\n\n    this.saveConfig(newConfig);\n  }\n\n  hasProfiles(): boolean {\n    return Object.keys(this.config.profiles).length > 0;\n  }\n}\n", "import { z } from 'zod';\n\nexport const EnvironmentSchema = z.enum(['sandbox', 'production']);\nexport type Environment = z.infer<typeof EnvironmentSchema>;\n\nexport const ProfileSchema = z.object({\n  api_key: z.string().min(1),\n  api_secret: z.string().min(1),\n  environment: EnvironmentSchema,\n});\nexport type Profile = z.infer<typeof ProfileSchema>;\n\nexport const ConfigSchema = z.object({\n  active_profile: z.string().nullable(),\n  profiles: z.record(z.string(), ProfileSchema),\n});\nexport type Config = z.infer<typeof ConfigSchema>;\n\nexport const DEFAULT_CONFIG: Config = {\n  active_profile: null,\n  profiles: {},\n};\n\nexport const CONFIG_DIR = '.eduzz-mcp';\nexport const CONFIG_FILE = 'config.json';\n\nexport interface ProfileInfo {\n  name: string;\n  environment: Environment;\n  isActive: boolean;\n}\n", "import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\nimport { ConfigManager } from './config-manager.js';\nimport { EnvironmentSchema } from './types.js';\n\nexport function registerConfigTools(server: McpServer, configManager: ConfigManager): void {\n  // Tool: List profiles\n  server.tool(\n    'eduzz_profile_list',\n    'List all configured Eduzz profiles',\n    {},\n    async () => {\n      const profiles = configManager.listProfiles();\n\n      if (profiles.length === 0) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No profiles configured. Use eduzz_profile_create to add a profile.',\n            },\n          ],\n        };\n      }\n\n      const profileList = profiles\n        .map((p) => {\n          const activeMarker = p.isActive ? ' (active)' : '';\n          return `- ${p.name}${activeMarker}: ${p.environment}`;\n        })\n        .join('\\n');\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Configured profiles:\\n${profileList}`,\n          },\n        ],\n      };\n    }\n  );\n\n  // Tool: Switch profile\n  server.tool(\n    'eduzz_profile_switch',\n    'Switch to a different Eduzz profile',\n    {\n      name: z.string().describe('Name of the profile to switch to'),\n    },\n    async ({ name }) => {\n      try {\n        configManager.switchProfile(name);\n        const profile = configManager.getProfile(name);\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Switched to profile \"${name}\" (${profile?.environment})`,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Create profile\n  server.tool(\n    'eduzz_profile_create',\n    'Create a new Eduzz profile with API credentials',\n    {\n      name: z.string().describe('Unique name for the profile'),\n      api_key: z.string().describe('Eduzz API key'),\n      api_secret: z.string().describe('Eduzz API secret'),\n      environment: EnvironmentSchema.describe('Environment: sandbox or production'),\n    },\n    async ({ name, api_key, api_secret, environment }) => {\n      try {\n        configManager.createProfile(name, api_key, api_secret, environment);\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Profile \"${name}\" created successfully (${environment})`,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Delete profile\n  server.tool(\n    'eduzz_profile_delete',\n    'Delete an Eduzz profile',\n    {\n      name: z.string().describe('Name of the profile to delete'),\n    },\n    async ({ name }) => {\n      try {\n        configManager.deleteProfile(name);\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Profile \"${name}\" deleted successfully`,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Get active profile info\n  server.tool(\n    'eduzz_profile_active',\n    'Get information about the currently active profile',\n    {},\n    async () => {\n      const active = configManager.getActiveProfile();\n\n      if (!active) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No active profile. Use eduzz_profile_create to add a profile.',\n            },\n          ],\n        };\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Active profile: ${active.name}\\nEnvironment: ${active.profile.environment}\\nAPI Key: ${active.profile.api_key.substring(0, 8)}...`,\n          },\n        ],\n      };\n    }\n  );\n\n}\n\nexport function createConfigServer(): McpServer {\n  const server = new McpServer({\n    name: 'eduzz-config',\n    version: '1.0.0',\n  });\n  registerConfigTools(server, new ConfigManager());\n  return server;\n}\n\nexport async function startServer(): Promise<void> {\n  const server = createConfigServer();\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}\n", "import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\nimport { join } from 'node:path';\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport cron from 'node-cron';\nimport { LocalEmbeddings } from './embeddings/local-embeddings.js';\nimport { OpenAPIProcessor } from './processors/openapi.js';\nimport { KnowledgeSyncer } from './sync.js';\nimport { getDataDir } from './paths.js';\n\nexport interface KnowledgeServerConfig {\n  openaiApiKey?: string;  // Optional - only for AI image descriptions\n  anthropicApiKey?: string;  // Optional - only for AI image descriptions\n  cronSchedule?: string; // Default: '0 3 * * 0' (Sunday 3am)\n}\n\nexport function registerKnowledgeTools(server: McpServer, config: KnowledgeServerConfig = {}): void {\n  const baseDir = getDataDir();\n  const embeddings = new LocalEmbeddings({\n    storagePath: baseDir,\n  });\n  const openApiProcessor = new OpenAPIProcessor(baseDir);\n  const syncer = new KnowledgeSyncer();\n\n  // Tool: Semantic search\n  server.tool(\n    'eduzz_search',\n    'Search the Eduzz knowledge base using semantic search',\n    {\n      query: z.string().describe('Search query'),\n      type: z.enum(['doc', 'example', 'api']).optional().describe('Filter by content type'),\n      language: z.string().optional().describe('Filter code examples by programming language'),\n      limit: z.number().int().min(1).max(50).default(10).describe('Maximum number of results'),\n    },\n    async ({ query, type, language, limit }) => {\n      try {\n        const filter: Record<string, string> = {};\n        if (type) filter.type = type;\n        if (language) filter.language = language;\n\n        const results = await embeddings.search(query, {\n          limit,\n          filter: Object.keys(filter).length > 0 ? filter : undefined,\n        });\n\n        if (results.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'No results found. Try a different query or run eduzz_sync to update the knowledge base.',\n              },\n            ],\n          };\n        }\n\n        const formatted = results\n          .map((r, i) => {\n            const meta = r.metadata;\n            return `## Result ${i + 1}\\n**URL:** ${meta.url}\\n**Type:** ${meta.type}\\n**Section:** ${meta.section}\\n${meta.language ? `**Language:** ${meta.language}\\n` : ''}\\n${r.content}\\n`;\n          })\n          .join('\\n---\\n\\n');\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: formatted,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error searching: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Get code examples\n  server.tool(\n    'eduzz_get_example',\n    'Get code examples for a specific topic',\n    {\n      topic: z.string().describe('Topic to find examples for (e.g., \"authentication\", \"webhooks\")'),\n      language: z.string().optional().describe('Programming language filter (e.g., \"javascript\", \"php\")'),\n      limit: z.number().int().min(1).max(20).default(5).describe('Maximum number of examples'),\n    },\n    async ({ topic, language, limit }) => {\n      try {\n        const filter: Record<string, string> = { type: 'example' };\n        if (language) filter.language = language.toLowerCase();\n\n        const results = await embeddings.search(topic, { limit, filter });\n\n        if (results.length === 0) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `No code examples found for \"${topic}\"${language ? ` in ${language}` : ''}.`,\n              },\n            ],\n          };\n        }\n\n        const examples = results\n          .map((r, i) => {\n            return `### Example ${i + 1} (${r.metadata.language || 'unknown'})\\nSource: ${r.metadata.url}\\n\\n${r.content}`;\n          })\n          .join('\\n\\n---\\n\\n');\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: examples,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Get endpoint documentation\n  server.tool(\n    'eduzz_get_endpoint',\n    'Get documentation for a specific API endpoint',\n    {\n      path: z.string().describe('API endpoint path (e.g., \"/invoices\", \"/users/{id}\")'),\n      method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']).optional().describe('HTTP method'),\n    },\n    async ({ path, method }) => {\n      try {\n        const spec = openApiProcessor.loadCachedSpec();\n\n        if (!spec) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: 'OpenAPI spec not found. Run eduzz_sync to fetch the API documentation.',\n              },\n            ],\n          };\n        }\n\n        const endpoint = openApiProcessor.getEndpointDoc(spec, path, method);\n\n        if (!endpoint) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `Endpoint \"${method || 'any'} ${path}\" not found in API documentation.`,\n              },\n            ],\n          };\n        }\n\n        const params = endpoint.parameters\n          .map((p) => `  - \\`${p.name}\\` (${p.in}${p.required ? ', required' : ''}): ${p.description}`)\n          .join('\\n');\n\n        const doc = `# ${endpoint.method} ${endpoint.path}\n\n**Summary:** ${endpoint.summary}\n\n${endpoint.description}\n\n## Parameters\n${params || 'No parameters'}\n\n## Request Body\n${endpoint.requestBody ? '```json\\n' + JSON.stringify(endpoint.requestBody, null, 2) + '\\n```' : 'No request body'}\n\n## Responses\n${Object.entries(endpoint.responses)\n  .map(([code, resp]) => `### ${code}\\n${JSON.stringify(resp, null, 2)}`)\n  .join('\\n\\n')}\n`;\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: doc,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Sync knowledge base\n  server.tool(\n    'eduzz_sync',\n    'Synchronize the knowledge base by crawling the Eduzz documentation. WARNING: This deletes all existing data and rebuilds from scratch.',\n    {},\n    async () => {\n      try {\n        const result = await syncer.sync({\n          openaiApiKey: config.openaiApiKey,\n          anthropicApiKey: config.anthropicApiKey,\n          onProgress: (msg) => console.log(msg),\n        });\n\n        const summary = `Sync completed:\n- Pages processed: ${result.pagesProcessed}\n- Images processed: ${result.imagesProcessed}\n- Code examples: ${result.codeExamplesProcessed}\n- Chunks indexed: ${result.chunksIndexed}\n${result.errors.length > 0 ? `\\nErrors:\\n${result.errors.join('\\n')}` : ''}`;\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: summary,\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Sync failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // Tool: Get stats\n  server.tool(\n    'eduzz_stats',\n    'Get statistics about the knowledge base',\n    {},\n    async () => {\n      const count = embeddings.count();\n      const spec = openApiProcessor.loadCachedSpec();\n\n      const pagesDir = join(baseDir, 'raw', 'pages');\n      const imagesDir = join(baseDir, 'raw', 'images');\n\n      let pageCount = 0;\n      let imageCount = 0;\n\n      if (existsSync(pagesDir)) {\n        pageCount = readdirSync(pagesDir).filter((f) => f.endsWith('.md')).length;\n      }\n      if (existsSync(imagesDir)) {\n        imageCount = readdirSync(imagesDir).filter(\n          (f) => f.endsWith('.png') || f.endsWith('.jpg') || f.endsWith('.jpeg')\n        ).length;\n      }\n\n      const stats = `Knowledge Base Statistics:\n- Indexed chunks: ${count}\n- Crawled pages: ${pageCount}\n- Downloaded images: ${imageCount}\n- API endpoints: ${spec?.endpoints.length || 0}\n- Storage path: ${baseDir}`;\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: stats,\n          },\n        ],\n      };\n    }\n  );\n\n  // Resources\n  server.resource(\n    'eduzz-docs-overview',\n    'eduzz://docs/overview',\n    async () => {\n      const overviewPath = join(baseDir, 'raw', 'pages');\n\n      if (!existsSync(overviewPath)) {\n        return {\n          contents: [\n            {\n              uri: 'eduzz://docs/overview',\n              mimeType: 'text/markdown',\n              text: 'No documentation available. Run eduzz_sync to fetch the documentation.',\n            },\n          ],\n        };\n      }\n\n      // Find main index/overview page\n      const files = readdirSync(overviewPath);\n      const indexFile = files.find(\n        (f) => f.includes('index') || f.includes('overview') || f.includes('getting-started')\n      );\n\n      if (indexFile) {\n        const content = readFileSync(join(overviewPath, indexFile), 'utf-8');\n        return {\n          contents: [\n            {\n              uri: 'eduzz://docs/overview',\n              mimeType: 'text/markdown',\n              text: content,\n            },\n          ],\n        };\n      }\n\n      // List available pages\n      const pageList = files\n        .filter((f) => f.endsWith('.md'))\n        .map((f) => `- ${f.replace('.md', '')}`)\n        .join('\\n');\n\n      return {\n        contents: [\n          {\n            uri: 'eduzz://docs/overview',\n            mimeType: 'text/markdown',\n            text: `# Available Documentation\\n\\n${pageList}`,\n          },\n        ],\n      };\n    }\n  );\n\n  server.resource(\n    'eduzz-openapi-spec',\n    'eduzz://openapi/spec.json',\n    async () => {\n      const spec = openApiProcessor.loadCachedSpec();\n\n      if (!spec) {\n        return {\n          contents: [\n            {\n              uri: 'eduzz://openapi/spec.json',\n              mimeType: 'application/json',\n              text: JSON.stringify({ error: 'OpenAPI spec not available' }),\n            },\n          ],\n        };\n      }\n\n      return {\n        contents: [\n          {\n            uri: 'eduzz://openapi/spec.json',\n            mimeType: 'application/json',\n            text: JSON.stringify(spec.spec, null, 2),\n          },\n        ],\n      };\n    }\n  );\n\n}\n\nexport function setupKnowledgeCron(config: KnowledgeServerConfig = {}): void {\n  const syncer = new KnowledgeSyncer();\n  const schedule = config.cronSchedule || '0 3 * * 0';\n  cron.schedule(schedule, async () => {\n    console.log('Running scheduled knowledge sync...');\n    await syncer.sync({\n      openaiApiKey: config.openaiApiKey,\n      anthropicApiKey: config.anthropicApiKey,\n    });\n  });\n}\n\nexport function createKnowledgeServer(config: KnowledgeServerConfig = {}): McpServer {\n  const server = new McpServer({\n    name: 'eduzz-knowledge',\n    version: '1.0.0',\n  });\n  registerKnowledgeTools(server, config);\n  setupKnowledgeCron(config);\n  return server;\n}\n\nexport async function startServer(config: KnowledgeServerConfig = {}): Promise<void> {\n  const server = createKnowledgeServer(config);\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}\n", "import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { createHash } from 'node:crypto';\nimport { DocumentChunk, ChunkMetadata } from '../types.js';\n\n// Dynamic import for transformers.js\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet embedder: any = null;\n\ninterface StoredDocument {\n  id: string;\n  content: string;\n  metadata: ChunkMetadata;\n  embedding: number[];\n}\n\ninterface LocalDatabase {\n  documents: StoredDocument[];\n  version: string;\n  lastUpdated: string;\n}\n\nexport interface SearchResult {\n  id: string;\n  content: string;\n  metadata: ChunkMetadata;\n  distance: number;\n}\n\nexport interface LocalEmbeddingsConfig {\n  storagePath: string;\n  modelName?: string;\n}\n\n/**\n * Local embeddings manager using Transformers.js\n * No API key required - runs 100% locally\n */\nexport class LocalEmbeddings {\n  private storagePath: string;\n  private dbPath: string;\n  private modelName: string;\n  private db: LocalDatabase;\n  private initialized: boolean = false;\n\n  constructor(config: LocalEmbeddingsConfig) {\n    this.storagePath = config.storagePath;\n    this.dbPath = join(config.storagePath, 'knowledge.db.json');\n    this.modelName = config.modelName || 'Xenova/all-MiniLM-L6-v2';\n\n    if (!existsSync(this.storagePath)) {\n      mkdirSync(this.storagePath, { recursive: true });\n    }\n\n    this.db = this.loadDatabase();\n  }\n\n  private loadDatabase(): LocalDatabase {\n    if (existsSync(this.dbPath)) {\n      try {\n        const content = readFileSync(this.dbPath, 'utf-8');\n        return JSON.parse(content) as LocalDatabase;\n      } catch {\n        return this.createEmptyDatabase();\n      }\n    }\n    return this.createEmptyDatabase();\n  }\n\n  private createEmptyDatabase(): LocalDatabase {\n    return {\n      documents: [],\n      version: '1.0.0',\n      lastUpdated: new Date().toISOString(),\n    };\n  }\n\n  private saveDatabase(): void {\n    this.db.lastUpdated = new Date().toISOString();\n    writeFileSync(this.dbPath, JSON.stringify(this.db, null, 2), 'utf-8');\n  }\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    console.log('Loading local embedding model (first run may take a moment to download)...');\n\n    // Dynamic import to avoid issues with ESM\n    const { pipeline } = await import('@xenova/transformers');\n\n    embedder = await pipeline('feature-extraction', this.modelName, {\n      quantized: true, // Use quantized model for faster inference\n    });\n\n    this.initialized = true;\n    console.log('Embedding model loaded successfully!');\n  }\n\n  private async generateEmbedding(text: string): Promise<number[]> {\n    if (!embedder) {\n      throw new Error('Embedder not initialized. Call initialize() first.');\n    }\n\n    const result = await embedder(text, { pooling: 'mean', normalize: true });\n    return Array.from(result.data as Float32Array);\n  }\n\n  private async generateEmbeddings(texts: string[]): Promise<number[][]> {\n    const embeddings: number[][] = [];\n\n    for (let i = 0; i < texts.length; i++) {\n      const embedding = await this.generateEmbedding(texts[i]);\n      embeddings.push(embedding);\n\n      // Progress indicator for large batches\n      if (texts.length > 10 && (i + 1) % 10 === 0) {\n        console.log(`Embedding progress: ${i + 1}/${texts.length}`);\n      }\n    }\n\n    return embeddings;\n  }\n\n  private generateChunkId(content: string, metadata: ChunkMetadata): string {\n    const hash = createHash('md5')\n      .update(content + JSON.stringify(metadata))\n      .digest('hex');\n    return hash.substring(0, 16);\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n\n  chunkText(text: string, maxTokens: number = 500): string[] {\n    const chunks: string[] = [];\n    const sentences = text.split(/(?<=[.!?])\\s+/);\n    let currentChunk = '';\n    let currentTokens = 0;\n\n    for (const sentence of sentences) {\n      const sentenceTokens = Math.ceil(sentence.length / 4);\n\n      if (currentTokens + sentenceTokens > maxTokens && currentChunk) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n        currentTokens = 0;\n      }\n\n      currentChunk += sentence + ' ';\n      currentTokens += sentenceTokens;\n    }\n\n    if (currentChunk.trim()) {\n      chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n  }\n\n  async addDocument(content: string, metadata: ChunkMetadata): Promise<string[]> {\n    await this.initialize();\n\n    const chunks = this.chunkText(content);\n    const ids: string[] = [];\n\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const chunkMetadata = {\n        ...metadata,\n        section: `${metadata.section}_chunk_${i}`,\n      };\n      const id = this.generateChunkId(chunk, chunkMetadata);\n\n      // Skip if already exists\n      if (this.db.documents.some((d) => d.id === id)) {\n        ids.push(id);\n        continue;\n      }\n\n      const embedding = await this.generateEmbedding(chunk);\n\n      this.db.documents.push({\n        id,\n        content: chunk,\n        metadata: chunkMetadata,\n        embedding,\n      });\n\n      ids.push(id);\n    }\n\n    this.saveDatabase();\n    return ids;\n  }\n\n  async addChunks(chunks: DocumentChunk[]): Promise<void> {\n    await this.initialize();\n\n    const newChunks = chunks.filter(\n      (c) => !this.db.documents.some((d) => d.id === c.id)\n    );\n\n    if (newChunks.length === 0) return;\n\n    console.log(`Generating embeddings for ${newChunks.length} chunks...`);\n    const embeddings = await this.generateEmbeddings(newChunks.map((c) => c.content));\n\n    for (let i = 0; i < newChunks.length; i++) {\n      this.db.documents.push({\n        id: newChunks[i].id,\n        content: newChunks[i].content,\n        metadata: newChunks[i].metadata,\n        embedding: embeddings[i],\n      });\n    }\n\n    this.saveDatabase();\n  }\n\n  async search(\n    query: string,\n    options: {\n      limit?: number;\n      filter?: Partial<ChunkMetadata>;\n    } = {}\n  ): Promise<SearchResult[]> {\n    await this.initialize();\n\n    const { limit = 10, filter } = options;\n    const queryEmbedding = await this.generateEmbedding(query);\n\n    let candidates = this.db.documents;\n\n    // Apply filters\n    if (filter) {\n      candidates = candidates.filter((doc) => {\n        for (const [key, value] of Object.entries(filter)) {\n          if (value !== undefined && doc.metadata[key as keyof ChunkMetadata] !== value) {\n            return false;\n          }\n        }\n        return true;\n      });\n    }\n\n    // Calculate similarities\n    const scored = candidates.map((doc) => ({\n      ...doc,\n      similarity: this.cosineSimilarity(queryEmbedding, doc.embedding),\n    }));\n\n    // Sort by similarity (descending) and take top results\n    scored.sort((a, b) => b.similarity - a.similarity);\n    const topResults = scored.slice(0, limit);\n\n    return topResults.map((doc) => ({\n      id: doc.id,\n      content: doc.content,\n      metadata: doc.metadata,\n      distance: 1 - doc.similarity, // Convert similarity to distance\n    }));\n  }\n\n  deleteByUrl(url: string): void {\n    this.db.documents = this.db.documents.filter((d) => d.metadata.url !== url);\n    this.saveDatabase();\n  }\n\n  clear(): void {\n    this.db = this.createEmptyDatabase();\n    this.saveDatabase();\n  }\n\n  count(): number {\n    return this.db.documents.length;\n  }\n}\n", "import { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { OpenAPISpec, APIEndpoint, APIParameter } from '../types.js';\n\nexport interface OpenAPIDocument {\n  openapi?: string;\n  swagger?: string;\n  info?: {\n    title?: string;\n    version?: string;\n    description?: string;\n  };\n  servers?: Array<{\n    url: string;\n    description?: string;\n  }>;\n  paths?: Record<string, Record<string, PathOperation>>;\n  components?: {\n    schemas?: Record<string, unknown>;\n    securitySchemes?: Record<string, unknown>;\n  };\n}\n\ninterface PathOperation {\n  summary?: string;\n  description?: string;\n  operationId?: string;\n  tags?: string[];\n  parameters?: ParameterObject[];\n  requestBody?: {\n    description?: string;\n    required?: boolean;\n    content?: Record<string, { schema?: unknown }>;\n  };\n  responses?: Record<string, ResponseObject>;\n  security?: Array<Record<string, string[]>>;\n}\n\ninterface ParameterObject {\n  name: string;\n  in: 'query' | 'path' | 'header' | 'cookie';\n  description?: string;\n  required?: boolean;\n  schema?: Record<string, unknown>;\n}\n\ninterface ResponseObject {\n  description?: string;\n  content?: Record<string, { schema?: unknown }>;\n}\n\nexport class OpenAPIProcessor {\n  private outputDir: string;\n\n  constructor(outputDir: string) {\n    this.outputDir = outputDir;\n  }\n\n  async fetchSpec(url: string): Promise<OpenAPIDocument | null> {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        console.error(`Failed to fetch OpenAPI spec from ${url}: ${response.status}`);\n        return null;\n      }\n\n      const contentType = response.headers.get('content-type') || '';\n      const text = await response.text();\n\n      if (contentType.includes('yaml') || url.endsWith('.yaml') || url.endsWith('.yml')) {\n        // Basic YAML parsing for simple specs\n        // For production, use a proper YAML parser\n        return JSON.parse(text) as OpenAPIDocument;\n      }\n\n      return JSON.parse(text) as OpenAPIDocument;\n    } catch (error) {\n      console.error(`Error fetching OpenAPI spec from ${url}:`, error);\n      return null;\n    }\n  }\n\n  parseEndpoints(spec: OpenAPIDocument): APIEndpoint[] {\n    const endpoints: APIEndpoint[] = [];\n\n    if (!spec.paths) {\n      return endpoints;\n    }\n\n    for (const [path, methods] of Object.entries(spec.paths)) {\n      for (const [method, operation] of Object.entries(methods)) {\n        if (['get', 'post', 'put', 'patch', 'delete'].includes(method.toLowerCase())) {\n          const op = operation as PathOperation;\n\n          const parameters: APIParameter[] = (op.parameters || []).map((p) => ({\n            name: p.name,\n            in: p.in,\n            required: p.required || false,\n            description: p.description || '',\n            schema: p.schema || {},\n          }));\n\n          endpoints.push({\n            method: method.toUpperCase(),\n            path,\n            summary: op.summary || '',\n            description: op.description || '',\n            parameters,\n            requestBody: op.requestBody as Record<string, unknown> | undefined,\n            responses: op.responses || {},\n          });\n        }\n      }\n    }\n\n    return endpoints;\n  }\n\n  async processSpec(url: string): Promise<OpenAPISpec | null> {\n    const spec = await this.fetchSpec(url);\n    if (!spec) {\n      return null;\n    }\n\n    const endpoints = this.parseEndpoints(spec);\n\n    const result: OpenAPISpec = {\n      url,\n      spec: spec as Record<string, unknown>,\n      endpoints,\n    };\n\n    // Save to file\n    const specPath = join(this.outputDir, 'raw', 'openapi', 'spec.json');\n    writeFileSync(specPath, JSON.stringify(result, null, 2), 'utf-8');\n\n    return result;\n  }\n\n  loadCachedSpec(): OpenAPISpec | null {\n    const specPath = join(this.outputDir, 'raw', 'openapi', 'spec.json');\n\n    if (!existsSync(specPath)) {\n      return null;\n    }\n\n    try {\n      const content = readFileSync(specPath, 'utf-8');\n      return JSON.parse(content) as OpenAPISpec;\n    } catch {\n      return null;\n    }\n  }\n\n  getEndpointDoc(spec: OpenAPISpec, path: string, method?: string): APIEndpoint | null {\n    const normalizedPath = path.toLowerCase();\n    const normalizedMethod = method?.toUpperCase();\n\n    for (const endpoint of spec.endpoints) {\n      const endpointPath = endpoint.path.toLowerCase();\n\n      // Exact match\n      if (endpointPath === normalizedPath) {\n        if (!normalizedMethod || endpoint.method === normalizedMethod) {\n          return endpoint;\n        }\n      }\n\n      // Pattern match (e.g., /users/{id} matches /users/123)\n      const pattern = endpointPath.replace(/\\{[^}]+\\}/g, '[^/]+');\n      const regex = new RegExp(`^${pattern}$`);\n      if (regex.test(normalizedPath)) {\n        if (!normalizedMethod || endpoint.method === normalizedMethod) {\n          return endpoint;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  generateToolSchema(endpoint: APIEndpoint): Record<string, unknown> {\n    const properties: Record<string, unknown> = {};\n    const required: string[] = [];\n\n    for (const param of endpoint.parameters) {\n      properties[param.name] = {\n        ...param.schema,\n        description: param.description,\n      };\n\n      if (param.required) {\n        required.push(param.name);\n      }\n    }\n\n    // Add body parameters if present\n    if (endpoint.requestBody) {\n      const body = endpoint.requestBody as {\n        content?: Record<string, { schema?: Record<string, unknown> }>;\n        required?: boolean;\n      };\n\n      const jsonContent = body.content?.['application/json'];\n      if (jsonContent?.schema) {\n        properties.body = jsonContent.schema;\n        if (body.required) {\n          required.push('body');\n        }\n      }\n    }\n\n    return {\n      type: 'object',\n      properties,\n      required: required.length > 0 ? required : undefined,\n    };\n  }\n}\n", "import { existsSync, mkdirSync, rmSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { Crawler } from './scraper/crawler.js';\nimport { CodeProcessor, ImageProcessor, OpenAPIProcessor } from './processors/index.js';\nimport { LocalEmbeddings } from './embeddings/local-embeddings.js';\nimport { ChunkMetadata, CrawledPage, DocumentChunk } from './types.js';\nimport { createHash } from 'node:crypto';\nimport { getDataDir } from './paths.js';\n\nexport interface SyncOptions {\n  openaiApiKey?: string;  // Optional - for AI image descriptions\n  anthropicApiKey?: string;  // Optional - for AI image descriptions\n  onProgress?: (message: string) => void;\n}\n\nexport interface SyncResult {\n  pagesProcessed: number;\n  imagesProcessed: number;\n  codeExamplesProcessed: number;\n  chunksIndexed: number;\n  errors: string[];\n}\n\nexport class KnowledgeSyncer {\n  private baseDir: string;\n  private codeProcessor: CodeProcessor;\n\n  constructor() {\n    this.baseDir = getDataDir();\n    this.codeProcessor = new CodeProcessor();\n\n    if (!existsSync(this.baseDir)) {\n      mkdirSync(this.baseDir, { recursive: true });\n    }\n  }\n\n  async sync(options: SyncOptions = {}): Promise<SyncResult> {\n    const { openaiApiKey, anthropicApiKey, onProgress } = options;\n\n    const result: SyncResult = {\n      pagesProcessed: 0,\n      imagesProcessed: 0,\n      codeExamplesProcessed: 0,\n      chunksIndexed: 0,\n      errors: [],\n    };\n\n    const log = (msg: string) => {\n      if (onProgress) onProgress(msg);\n      console.log(msg);\n    };\n\n    try {\n      // Step 0: Clean existing data\n      log('Cleaning existing data...');\n      const rawDir = join(this.baseDir, 'raw');\n      if (existsSync(rawDir)) {\n        rmSync(rawDir, { recursive: true, force: true });\n      }\n      mkdirSync(rawDir, { recursive: true });\n\n      // Step 1: Crawl the documentation site\n      log('Starting crawl of developers.eduzz.com...');\n      const crawler = new Crawler(this.baseDir);\n      const pages = await crawler.crawl((url, count) => {\n        log(`[${count}] Crawling: ${url}`);\n      });\n      result.pagesProcessed = pages.length;\n      log(`Crawled ${pages.length} pages`);\n\n      // Step 2: Process images with OCR (offline, no API needed)\n      log('Processing images with OCR...');\n      const imageProcessor = new ImageProcessor();\n      const allImages = pages.flatMap((p) => p.images);\n\n      if (allImages.length > 0) {\n        // Always use OCR by default (100% offline)\n        // AI descriptions are optional enhancement if API keys provided\n        if (openaiApiKey || anthropicApiKey) {\n          log('Using AI for enhanced image descriptions...');\n          await imageProcessor.processImagesWithAI(allImages, { openaiApiKey, anthropicApiKey });\n          log(`Processed ${allImages.length} images with AI descriptions`);\n        } else {\n          // OCR extracts text from images offline\n          await imageProcessor.processImages(allImages);\n          log(`Processed ${allImages.length} images with OCR`);\n        }\n        result.imagesProcessed = allImages.length;\n      }\n\n      // Step 3: Check for OpenAPI specs\n      log('Looking for OpenAPI specs...');\n      const openApiProcessor = new OpenAPIProcessor(this.baseDir);\n      const openApiUrls = this.findOpenAPILinks(pages);\n      for (const url of openApiUrls) {\n        log(`Processing OpenAPI spec: ${url}`);\n        await openApiProcessor.processSpec(url);\n      }\n\n      // Step 4: Index everything with local embeddings (no API key needed!)\n      log('Indexing content for semantic search (using local embeddings)...');\n      const embeddings = new LocalEmbeddings({\n        storagePath: this.baseDir,\n      });\n\n      // Sempre limpa o \u00EDndice antes de reconstruir\n      log('Clearing existing index...');\n      embeddings.clear();\n\n      // Initialize embeddings (downloads model on first run)\n      await embeddings.initialize();\n\n      // Index page content\n      const chunks = this.createChunks(pages);\n      await embeddings.addChunks(chunks);\n      result.chunksIndexed = chunks.length;\n\n      // Index code examples\n      const codeChunks = this.createCodeChunks(pages);\n      await embeddings.addChunks(codeChunks);\n      result.codeExamplesProcessed = codeChunks.length;\n      result.chunksIndexed += codeChunks.length;\n\n      log(`Indexed ${result.chunksIndexed} chunks`);\n      log('Sync complete!');\n\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n      result.errors.push(errorMsg);\n      log(`Error during sync: ${errorMsg}`);\n    }\n\n    return result;\n  }\n\n  private findOpenAPILinks(pages: CrawledPage[]): string[] {\n    const openApiUrls: string[] = [];\n\n    for (const page of pages) {\n      // Look for OpenAPI/Swagger links in markdown\n      const matches = page.markdown.matchAll(\n        /https?:\\/\\/[^\\s)]+(?:openapi|swagger|api-docs)[^\\s)]*.(?:json|yaml|yml)/gi\n      );\n      for (const match of matches) {\n        openApiUrls.push(match[0]);\n      }\n\n      // Check links that might be OpenAPI specs\n      for (const link of page.links) {\n        if (\n          link.includes('openapi') ||\n          link.includes('swagger') ||\n          link.includes('api-docs') ||\n          link.endsWith('.json') ||\n          link.endsWith('.yaml') ||\n          link.endsWith('.yml')\n        ) {\n          openApiUrls.push(link);\n        }\n      }\n    }\n\n    return [...new Set(openApiUrls)];\n  }\n\n  private createChunks(pages: CrawledPage[]): DocumentChunk[] {\n    const chunks: DocumentChunk[] = [];\n\n    for (const page of pages) {\n      const url = page.url;\n      const title = page.title;\n\n      // Split content into sections by headers\n      const sections = page.markdown.split(/(?=^#{1,3}\\s)/m);\n\n      for (let i = 0; i < sections.length; i++) {\n        const section = sections[i].trim();\n        if (!section || section.length < 50) continue;\n\n        const sectionTitle = section.match(/^#{1,3}\\s+(.+)/)?.[1] || `section_${i}`;\n        const id = createHash('md5')\n          .update(url + section)\n          .digest('hex')\n          .substring(0, 16);\n\n        const metadata: ChunkMetadata = {\n          url,\n          type: 'doc',\n          section: sectionTitle,\n          title,\n        };\n\n        chunks.push({\n          id,\n          content: section,\n          metadata,\n        });\n      }\n    }\n\n    return chunks;\n  }\n\n  private createCodeChunks(pages: CrawledPage[]): DocumentChunk[] {\n    const chunks: DocumentChunk[] = [];\n\n    for (const page of pages) {\n      const processed = this.codeProcessor.processCodeBlocks(page.codeBlocks);\n\n      for (const code of processed) {\n        const id = createHash('md5')\n          .update(page.url + code.code)\n          .digest('hex')\n          .substring(0, 16);\n\n        const content = `${code.context}\\n\\n\\`\\`\\`${code.language}\\n${code.code}\\n\\`\\`\\``;\n\n        const metadata: ChunkMetadata = {\n          url: page.url,\n          type: 'example',\n          section: code.category,\n          language: code.language,\n          title: page.title,\n        };\n\n        chunks.push({\n          id,\n          content,\n          metadata,\n        });\n      }\n    }\n\n    return chunks;\n  }\n\n  getStoragePath(): string {\n    return this.baseDir;\n  }\n}\n", "import { chromium, Browser, Page } from 'playwright';\nimport { existsSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { createHash } from 'node:crypto';\nimport TurndownService from 'turndown';\nimport {\n  CrawledPage,\n  CrawledImage,\n  CodeBlock,\n  CrawlerConfig,\n  DEFAULT_CRAWLER_CONFIG,\n} from '../types.js';\n\nexport class Crawler {\n  private config: CrawlerConfig;\n  private browser: Browser | null = null;\n  private visited: Set<string> = new Set();\n  private queue: string[] = [];\n  private turndown: TurndownService;\n  private outputDir: string;\n\n  constructor(outputDir: string, config: Partial<CrawlerConfig> = {}) {\n    this.config = { ...DEFAULT_CRAWLER_CONFIG, ...config };\n    this.outputDir = outputDir;\n    this.turndown = new TurndownService({\n      headingStyle: 'atx',\n      codeBlockStyle: 'fenced',\n    });\n\n    // Create output directories\n    const dirs = ['pages', 'images', 'code-examples', 'openapi'];\n    for (const dir of dirs) {\n      const path = join(outputDir, 'raw', dir);\n      if (!existsSync(path)) {\n        mkdirSync(path, { recursive: true });\n      }\n    }\n  }\n\n  private generateId(url: string): string {\n    return createHash('md5').update(url).digest('hex').substring(0, 12);\n  }\n\n  private normalizeUrl(url: string, baseUrl: string): string | null {\n    try {\n      const parsed = new URL(url, baseUrl);\n\n      // Only allow same domain\n      if (!parsed.hostname.includes(this.config.domainFilter)) {\n        return null;\n      }\n\n      // Remove hash and trailing slash\n      parsed.hash = '';\n      let normalized = parsed.toString();\n      if (normalized.endsWith('/') && normalized !== this.config.baseUrl) {\n        normalized = normalized.slice(0, -1);\n      }\n\n      return normalized;\n    } catch {\n      return null;\n    }\n  }\n\n  private async extractImages(page: Page, pageUrl: string): Promise<CrawledImage[]> {\n    const images: CrawledImage[] = [];\n\n    const imgElements = await page.locator('img').all();\n    for (const img of imgElements) {\n      const src = await img.getAttribute('src');\n      const alt = await img.getAttribute('alt') || '';\n\n      if (src) {\n        const imgUrl = this.normalizeUrl(src, pageUrl);\n        if (imgUrl) {\n          const id = this.generateId(imgUrl);\n          const ext = imgUrl.split('.').pop()?.split('?')[0] || 'png';\n          const localPath = join(this.outputDir, 'raw', 'images', `${id}.${ext}`);\n\n          images.push({\n            url: imgUrl,\n            alt,\n            localPath,\n          });\n        }\n      }\n    }\n\n    return images;\n  }\n\n  private async extractCodeBlocks(page: Page): Promise<CodeBlock[]> {\n    const codeBlocks: CodeBlock[] = [];\n\n    const codeElements = await page.locator('pre code, pre').all();\n    for (const code of codeElements) {\n      const text = await code.textContent();\n      if (!text) continue;\n\n      // Try to detect language from class\n      const className = await code.getAttribute('class') || '';\n      let language = 'text';\n\n      const langMatch = className.match(/language-(\\w+)|lang-(\\w+)|(\\w+)/);\n      if (langMatch) {\n        language = langMatch[1] || langMatch[2] || langMatch[3] || 'text';\n      }\n\n      // Get surrounding context from previous sibling text\n      let context = '';\n      try {\n        const parentLocator = page.locator('pre code, pre').filter({ has: code }).locator('..');\n        const prevSibling = parentLocator.locator('xpath=preceding-sibling::*[1]');\n        if (await prevSibling.count() > 0) {\n          const siblingText = await prevSibling.textContent();\n          context = siblingText?.substring(0, 200) || '';\n        }\n      } catch {\n        // Context extraction is optional\n      }\n\n      codeBlocks.push({\n        language,\n        code: text.trim(),\n        context,\n      });\n    }\n\n    return codeBlocks;\n  }\n\n  private async extractLinks(page: Page, pageUrl: string): Promise<string[]> {\n    const links: string[] = [];\n\n    const anchors = await page.locator('a[href]').all();\n    for (const anchor of anchors) {\n      const href = await anchor.getAttribute('href');\n      if (href) {\n        const normalized = this.normalizeUrl(href, pageUrl);\n        if (normalized && !this.visited.has(normalized)) {\n          links.push(normalized);\n        }\n      }\n    }\n\n    return [...new Set(links)];\n  }\n\n  private async crawlPage(page: Page, url: string): Promise<CrawledPage | null> {\n    try {\n      await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });\n\n      const title = await page.title();\n      const content = await page.content();\n\n      // Extract main content area\n      const mainSelectors = ['main', 'article', '.content', '.documentation', '#content'];\n      let htmlContent = '';\n\n      for (const selector of mainSelectors) {\n        const mainContent = page.locator(selector).first();\n        if (await mainContent.count() > 0) {\n          htmlContent = await mainContent.innerHTML();\n          break;\n        }\n      }\n\n      if (!htmlContent) {\n        htmlContent = await page.locator('body').innerHTML();\n      }\n\n      const markdown = this.turndown.turndown(htmlContent);\n      const images = await this.extractImages(page, url);\n      const codeBlocks = await this.extractCodeBlocks(page);\n      const links = await this.extractLinks(page, url);\n\n      return {\n        url,\n        title,\n        content,\n        markdown,\n        images,\n        codeBlocks,\n        links,\n        crawledAt: new Date(),\n      };\n    } catch (error) {\n      console.error(`Error crawling ${url}:`, error);\n      return null;\n    }\n  }\n\n  private async downloadImage(url: string, localPath: string): Promise<void> {\n    try {\n      const response = await fetch(url);\n      if (response.ok) {\n        const buffer = await response.arrayBuffer();\n        writeFileSync(localPath, Buffer.from(buffer));\n      }\n    } catch (error) {\n      console.error(`Error downloading image ${url}:`, error);\n    }\n  }\n\n  private savePage(crawled: CrawledPage): void {\n    const id = this.generateId(crawled.url);\n\n    // Save markdown\n    const mdPath = join(this.outputDir, 'raw', 'pages', `${id}.md`);\n    const mdContent = `---\nurl: ${crawled.url}\ntitle: ${crawled.title}\ncrawledAt: ${crawled.crawledAt.toISOString()}\n---\n\n# ${crawled.title}\n\n${crawled.markdown}\n`;\n    writeFileSync(mdPath, mdContent, 'utf-8');\n\n    // Save code examples\n    if (crawled.codeBlocks.length > 0) {\n      const examplesPath = join(this.outputDir, 'raw', 'code-examples', `${id}.json`);\n      writeFileSync(\n        examplesPath,\n        JSON.stringify(\n          {\n            url: crawled.url,\n            examples: crawled.codeBlocks,\n          },\n          null,\n          2\n        ),\n        'utf-8'\n      );\n    }\n  }\n\n  async crawl(onProgress?: (url: string, total: number) => void): Promise<CrawledPage[]> {\n    const results: CrawledPage[] = [];\n\n    this.browser = await chromium.launch({ headless: true });\n    const context = await this.browser.newContext({\n      userAgent:\n        'Mozilla/5.0 (compatible; EduzzMCPBot/1.0; +https://github.com/eduzz/mcp-knowledge)',\n    });\n\n    const page = await context.newPage();\n\n    this.queue.push(this.config.baseUrl);\n\n    let processedCount = 0;\n\n    while (this.queue.length > 0 && processedCount < this.config.maxDepth) {\n      const url = this.queue.shift()!;\n\n      if (this.visited.has(url)) continue;\n      this.visited.add(url);\n\n      if (onProgress) {\n        onProgress(url, processedCount + 1);\n      }\n\n      const crawled = await this.crawlPage(page, url);\n      if (crawled) {\n        results.push(crawled);\n        this.savePage(crawled);\n\n        // Download images\n        for (const img of crawled.images) {\n          if (!existsSync(img.localPath)) {\n            await this.downloadImage(img.url, img.localPath);\n          }\n        }\n\n        // Add new links to queue\n        for (const link of crawled.links) {\n          if (!this.visited.has(link) && !this.queue.includes(link)) {\n            this.queue.push(link);\n          }\n        }\n\n        processedCount++;\n      }\n\n      // Respect rate limiting\n      await new Promise((resolve) => setTimeout(resolve, this.config.delay));\n    }\n\n    await this.browser.close();\n    this.browser = null;\n\n    return results;\n  }\n\n  async stop(): Promise<void> {\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = null;\n    }\n  }\n}\n", "import { z } from 'zod';\n\nexport interface CrawledPage {\n  url: string;\n  title: string;\n  content: string;\n  markdown: string;\n  images: CrawledImage[];\n  codeBlocks: CodeBlock[];\n  links: string[];\n  crawledAt: Date;\n}\n\nexport interface CrawledImage {\n  url: string;\n  alt: string;\n  localPath: string;\n  description?: string;\n}\n\nexport interface CodeBlock {\n  language: string;\n  code: string;\n  context: string;\n}\n\nexport interface OpenAPISpec {\n  url: string;\n  spec: Record<string, unknown>;\n  endpoints: APIEndpoint[];\n}\n\nexport interface APIEndpoint {\n  method: string;\n  path: string;\n  summary: string;\n  description: string;\n  parameters: APIParameter[];\n  requestBody?: Record<string, unknown>;\n  responses: Record<string, unknown>;\n}\n\nexport interface APIParameter {\n  name: string;\n  in: 'query' | 'path' | 'header' | 'cookie';\n  required: boolean;\n  description: string;\n  schema: Record<string, unknown>;\n}\n\nexport interface DocumentChunk {\n  id: string;\n  content: string;\n  metadata: ChunkMetadata;\n}\n\nexport interface ChunkMetadata {\n  url: string;\n  type: 'doc' | 'example' | 'api';\n  section: string;\n  language?: string;\n  title?: string;\n}\n\nexport const CrawlerConfigSchema = z.object({\n  baseUrl: z.string().url().default('https://developers.eduzz.com/'),\n  maxDepth: z.number().int().positive().default(10000),\n  domainFilter: z.string().default('developers.eduzz.com'),\n  concurrency: z.number().int().positive().default(5),\n  delay: z.number().int().nonnegative().default(500),\n});\n\nexport type CrawlerConfig = z.infer<typeof CrawlerConfigSchema>;\n\nexport const DEFAULT_CRAWLER_CONFIG: CrawlerConfig = {\n  baseUrl: 'https://developers.eduzz.com/',\n  maxDepth: 10000,\n  domainFilter: 'developers.eduzz.com',\n  concurrency: 5,\n  delay: 500,\n};\n", "import TurndownService from 'turndown';\n\ninterface DOMNode {\n  nodeName: string;\n  querySelector: (selector: string) => DOMNode | null;\n  className?: string;\n  textContent?: string | null;\n}\n\nexport class HtmlProcessor {\n  private turndown: TurndownService;\n\n  constructor() {\n    this.turndown = new TurndownService({\n      headingStyle: 'atx',\n      codeBlockStyle: 'fenced',\n      bulletListMarker: '-',\n    });\n\n    // Add custom rules for better documentation conversion\n    this.turndown.addRule('codeBlock', {\n      filter: (node) => {\n        return (\n          node.nodeName === 'PRE' &&\n          node.querySelector('code') !== null\n        );\n      },\n      replacement: (content, node) => {\n        const codeElement = (node as DOMNode).querySelector('code');\n        const className = codeElement?.className || '';\n        const langMatch = className.match(/language-(\\w+)/);\n        const lang = langMatch ? langMatch[1] : '';\n        const code = codeElement?.textContent || content;\n        return `\\n\\`\\`\\`${lang}\\n${code.trim()}\\n\\`\\`\\`\\n`;\n      },\n    });\n\n    // Remove navigation elements\n    this.turndown.addRule('removeNav', {\n      filter: ['nav', 'header', 'footer'],\n      replacement: () => '',\n    });\n\n    // Clean up sidebars\n    this.turndown.addRule('removeSidebar', {\n      filter: (node) => {\n        const className = (node as DOMNode).className || '';\n        return (\n          className.includes('sidebar') ||\n          className.includes('nav') ||\n          className.includes('menu')\n        );\n      },\n      replacement: () => '',\n    });\n  }\n\n  toMarkdown(html: string): string {\n    return this.turndown.turndown(html);\n  }\n\n  extractTitle(html: string): string {\n    const titleMatch = html.match(/<title[^>]*>([^<]+)<\\/title>/i);\n    if (titleMatch) {\n      return titleMatch[1].trim();\n    }\n\n    const h1Match = html.match(/<h1[^>]*>([^<]+)<\\/h1>/i);\n    if (h1Match) {\n      return h1Match[1].trim();\n    }\n\n    return 'Untitled';\n  }\n\n  extractMetaDescription(html: string): string {\n    const metaMatch = html.match(\n      /<meta[^>]+name=[\"']description[\"'][^>]+content=[\"']([^\"']+)[\"']/i\n    );\n    return metaMatch ? metaMatch[1].trim() : '';\n  }\n\n  cleanHtml(html: string): string {\n    // Remove script and style tags\n    let cleaned = html.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '');\n    cleaned = cleaned.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '');\n\n    // Remove comments\n    cleaned = cleaned.replace(/<!--[\\s\\S]*?-->/g, '');\n\n    // Remove inline styles\n    cleaned = cleaned.replace(/\\s*style=[\"'][^\"']*[\"']/gi, '');\n\n    return cleaned;\n  }\n}\n", "import { CodeBlock } from '../types.js';\n\nexport interface ExtractedCode {\n  language: string;\n  code: string;\n  context: string;\n  category: CodeCategory;\n}\n\nexport type CodeCategory =\n  | 'authentication'\n  | 'api-call'\n  | 'webhook'\n  | 'error-handling'\n  | 'data-model'\n  | 'configuration'\n  | 'example'\n  | 'other';\n\nexport class CodeProcessor {\n  private languageAliases: Record<string, string> = {\n    js: 'javascript',\n    ts: 'typescript',\n    py: 'python',\n    rb: 'ruby',\n    cs: 'csharp',\n    'c#': 'csharp',\n    sh: 'bash',\n    shell: 'bash',\n    yml: 'yaml',\n    json5: 'json',\n  };\n\n  normalizeLanguage(language: string): string {\n    const normalized = language.toLowerCase().trim();\n    return this.languageAliases[normalized] || normalized;\n  }\n\n  categorizeCode(code: string, context: string): CodeCategory {\n    const combined = (code + ' ' + context).toLowerCase();\n\n    // Authentication patterns\n    if (\n      combined.includes('api_key') ||\n      combined.includes('api_secret') ||\n      combined.includes('authorization') ||\n      combined.includes('bearer') ||\n      combined.includes('token') ||\n      combined.includes('authenticate')\n    ) {\n      return 'authentication';\n    }\n\n    // Webhook patterns\n    if (\n      combined.includes('webhook') ||\n      combined.includes('callback') ||\n      combined.includes('notification') ||\n      combined.includes('postback')\n    ) {\n      return 'webhook';\n    }\n\n    // Error handling patterns\n    if (\n      combined.includes('catch') ||\n      combined.includes('error') ||\n      combined.includes('exception') ||\n      combined.includes('try {')\n    ) {\n      return 'error-handling';\n    }\n\n    // API call patterns\n    if (\n      combined.includes('fetch(') ||\n      combined.includes('axios') ||\n      combined.includes('httpclient') ||\n      combined.includes('request(') ||\n      combined.includes('/api/') ||\n      combined.includes('curl')\n    ) {\n      return 'api-call';\n    }\n\n    // Data model patterns\n    if (\n      combined.includes('interface ') ||\n      combined.includes('type ') ||\n      combined.includes('class ') ||\n      combined.includes('struct ') ||\n      combined.includes('schema')\n    ) {\n      return 'data-model';\n    }\n\n    // Configuration patterns\n    if (\n      combined.includes('config') ||\n      combined.includes('.env') ||\n      combined.includes('settings') ||\n      combined.includes('environment')\n    ) {\n      return 'configuration';\n    }\n\n    // Example patterns\n    if (\n      combined.includes('example') ||\n      combined.includes('sample') ||\n      combined.includes('demo')\n    ) {\n      return 'example';\n    }\n\n    return 'other';\n  }\n\n  processCodeBlocks(blocks: CodeBlock[]): ExtractedCode[] {\n    return blocks.map((block) => ({\n      language: this.normalizeLanguage(block.language),\n      code: this.cleanCode(block.code),\n      context: block.context,\n      category: this.categorizeCode(block.code, block.context),\n    }));\n  }\n\n  cleanCode(code: string): string {\n    // Remove leading/trailing whitespace\n    let cleaned = code.trim();\n\n    // Normalize line endings\n    cleaned = cleaned.replace(/\\r\\n/g, '\\n');\n\n    // Remove excessive blank lines\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\n\n    return cleaned;\n  }\n\n  filterByLanguage(codes: ExtractedCode[], languages: string[]): ExtractedCode[] {\n    const normalizedLangs = languages.map((l) => this.normalizeLanguage(l));\n    return codes.filter((c) => normalizedLangs.includes(c.language));\n  }\n\n  filterByCategory(codes: ExtractedCode[], categories: CodeCategory[]): ExtractedCode[] {\n    return codes.filter((c) => categories.includes(c.category));\n  }\n}\n", "import { readFileSync, writeFileSync, existsSync } from 'node:fs';\nimport { dirname } from 'node:path';\nimport { mkdirSync } from 'node:fs';\nimport Tesseract from 'tesseract.js';\nimport { CrawledImage } from '../types.js';\n\nexport interface ImageDescription {\n  url: string;\n  localPath: string;\n  description: string;\n  alt: string;\n}\n\nexport class ImageProcessor {\n  private worker: Tesseract.Worker | null = null;\n\n  /**\n   * Initialize Tesseract worker for OCR.\n   * Downloads language data on first run (~15MB for por+eng).\n   */\n  private async getWorker(): Promise<Tesseract.Worker> {\n    if (!this.worker) {\n      console.log('Initializing OCR engine (first run downloads language data)...');\n      this.worker = await Tesseract.createWorker(['por', 'eng'], 1, {\n        logger: (m) => {\n          if (m.status === 'recognizing text') {\n            process.stdout.write(`\\rOCR progress: ${Math.round(m.progress * 100)}%`);\n          }\n        },\n      });\n    }\n    return this.worker;\n  }\n\n  /**\n   * Terminate the OCR worker to free resources.\n   */\n  async terminate(): Promise<void> {\n    if (this.worker) {\n      await this.worker.terminate();\n      this.worker = null;\n    }\n  }\n\n  /**\n   * Extract text from image using Tesseract OCR (offline).\n   */\n  private async extractTextWithOCR(imagePath: string): Promise<string> {\n    try {\n      const worker = await this.getWorker();\n      const { data } = await worker.recognize(imagePath);\n      process.stdout.write('\\n'); // New line after progress\n      return data.text.trim();\n    } catch (error) {\n      console.error(`OCR failed for ${imagePath}:`, error);\n      return '';\n    }\n  }\n\n  /**\n   * Process images using offline OCR (Tesseract.js).\n   * No API key required - runs 100% locally.\n   */\n  async processImages(images: CrawledImage[]): Promise<ImageDescription[]> {\n    const descriptions: ImageDescription[] = [];\n\n    console.log(`Processing ${images.length} images with OCR...`);\n\n    for (let i = 0; i < images.length; i++) {\n      const img = images[i];\n      const descriptionPath = img.localPath.replace(/\\.[^.]+$/, '.description.md');\n\n      console.log(`[${i + 1}/${images.length}] Processing: ${img.localPath}`);\n\n      // Check if description already exists\n      if (existsSync(descriptionPath)) {\n        const existingDescription = readFileSync(descriptionPath, 'utf-8');\n        descriptions.push({\n          url: img.url,\n          localPath: img.localPath,\n          description: existingDescription,\n          alt: img.alt,\n        });\n        continue;\n      }\n\n      if (!existsSync(img.localPath)) {\n        descriptions.push({\n          url: img.url,\n          localPath: img.localPath,\n          description: img.alt || 'Image not found',\n          alt: img.alt,\n        });\n        continue;\n      }\n\n      // Skip SVG files (not supported by OCR)\n      const ext = img.localPath.toLowerCase().split('.').pop();\n      if (ext === 'svg') {\n        const title = img.alt || 'SVG Image';\n        const description = `# ${title}\\n\\n_SVG images cannot be processed with OCR_\\n`;\n\n        const dir = dirname(descriptionPath);\n        if (!existsSync(dir)) {\n          mkdirSync(dir, { recursive: true });\n        }\n        writeFileSync(descriptionPath, description, 'utf-8');\n\n        descriptions.push({\n          url: img.url,\n          localPath: img.localPath,\n          description,\n          alt: img.alt,\n        });\n        continue;\n      }\n\n      // Extract text using OCR\n      const extractedText = await this.extractTextWithOCR(img.localPath);\n\n      // Build description markdown\n      const title = img.alt || 'Eduzz Documentation Image';\n      let description = `# ${title}\\n\\n`;\n\n      if (extractedText) {\n        description += `## Extracted Text\\n\\n\\`\\`\\`\\n${extractedText}\\n\\`\\`\\`\\n`;\n      } else {\n        description += `## Extracted Text\\n\\n_No text detected in image_\\n`;\n      }\n\n      // Save description\n      const dir = dirname(descriptionPath);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n      }\n      writeFileSync(descriptionPath, description, 'utf-8');\n\n      descriptions.push({\n        url: img.url,\n        localPath: img.localPath,\n        description,\n        alt: img.alt,\n      });\n    }\n\n    // Cleanup worker\n    await this.terminate();\n\n    return descriptions;\n  }\n\n  /**\n   * Process images with AI vision API (optional enhancement).\n   * Provides richer descriptions than OCR alone.\n   * Requires either OpenAI or Anthropic API key.\n   */\n  async processImagesWithAI(\n    images: CrawledImage[],\n    options: {\n      openaiApiKey?: string;\n      anthropicApiKey?: string;\n    }\n  ): Promise<ImageDescription[]> {\n    const descriptions: ImageDescription[] = [];\n\n    for (const img of images) {\n      const descriptionPath = img.localPath.replace(/\\.[^.]+$/, '.description.md');\n\n      if (existsSync(descriptionPath)) {\n        const existingDescription = readFileSync(descriptionPath, 'utf-8');\n        descriptions.push({\n          url: img.url,\n          localPath: img.localPath,\n          description: existingDescription,\n          alt: img.alt,\n        });\n        continue;\n      }\n\n      if (!existsSync(img.localPath)) {\n        descriptions.push({\n          url: img.url,\n          localPath: img.localPath,\n          description: img.alt || 'Image not found',\n          alt: img.alt,\n        });\n        continue;\n      }\n\n      let description = img.alt || 'Image from Eduzz documentation';\n\n      // Try OpenAI first\n      if (options.openaiApiKey) {\n        try {\n          description = await this.describeWithOpenAI(img.localPath, img.alt, options.openaiApiKey);\n        } catch (error) {\n          console.error(`OpenAI vision failed for ${img.localPath}:`, error);\n        }\n      }\n      // Fall back to Anthropic\n      else if (options.anthropicApiKey) {\n        try {\n          description = await this.describeWithClaude(img.localPath, img.alt, options.anthropicApiKey);\n        } catch (error) {\n          console.error(`Claude vision failed for ${img.localPath}:`, error);\n        }\n      }\n\n      // Save description\n      const dir = dirname(descriptionPath);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n      }\n      writeFileSync(descriptionPath, description, 'utf-8');\n\n      descriptions.push({\n        url: img.url,\n        localPath: img.localPath,\n        description,\n        alt: img.alt,\n      });\n\n      // Rate limiting\n      await new Promise((resolve) => setTimeout(resolve, 500));\n    }\n\n    return descriptions;\n  }\n\n  private getMimeType(filePath: string): string {\n    const ext = filePath.toLowerCase().split('.').pop();\n    const mimeTypes: Record<string, string> = {\n      png: 'image/png',\n      jpg: 'image/jpeg',\n      jpeg: 'image/jpeg',\n      gif: 'image/gif',\n      webp: 'image/webp',\n      svg: 'image/svg+xml',\n    };\n    return mimeTypes[ext || ''] || 'image/png';\n  }\n\n  private async describeWithOpenAI(imagePath: string, alt: string, apiKey: string): Promise<string> {\n    const imageBuffer = readFileSync(imagePath);\n    const base64Image = imageBuffer.toString('base64');\n    const mimeType = this.getMimeType(imagePath);\n\n    const prompt = `Analyze this documentation image and provide:\n\n1. **Title**: A brief descriptive title (use the alt text \"${alt}\" as reference if helpful)\n\n2. **Extracted Text**: Extract ALL visible text from the image exactly as shown, preserving structure:\n   - Menu items, labels, buttons\n   - Form fields and their descriptions\n   - Error messages, tooltips\n   - Code snippets\n   - Any other readable text\n\n3. **Context**: Brief description of what the image shows (UI screen, diagram, code example, etc.)\n\nFormat the response as markdown with clear sections.`;\n\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-4o',\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'text',\n                text: prompt,\n              },\n              {\n                type: 'image_url',\n                image_url: { url: `data:${mimeType};base64,${base64Image}` },\n              },\n            ],\n          },\n        ],\n        max_tokens: 1500,\n      }),\n    });\n\n    const data = await response.json() as {\n      choices?: Array<{ message?: { content?: string } }>;\n    };\n\n    return data.choices?.[0]?.message?.content || alt || 'Unable to describe image';\n  }\n\n  private async describeWithClaude(imagePath: string, alt: string, apiKey: string): Promise<string> {\n    const imageBuffer = readFileSync(imagePath);\n    const base64Image = imageBuffer.toString('base64');\n    const mediaType = this.getMimeType(imagePath) as 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp';\n\n    const prompt = `Analyze this documentation image and provide:\n\n1. **Title**: A brief descriptive title (use the alt text \"${alt}\" as reference if helpful)\n\n2. **Extracted Text**: Extract ALL visible text from the image exactly as shown, preserving structure:\n   - Menu items, labels, buttons\n   - Form fields and their descriptions\n   - Error messages, tooltips\n   - Code snippets\n   - Any other readable text\n\n3. **Context**: Brief description of what the image shows (UI screen, diagram, code example, etc.)\n\nFormat the response as markdown with clear sections.`;\n\n    const response = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n      },\n      body: JSON.stringify({\n        model: 'claude-sonnet-4-20250514',\n        max_tokens: 1500,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'image',\n                source: { type: 'base64', media_type: mediaType, data: base64Image },\n              },\n              {\n                type: 'text',\n                text: prompt,\n              },\n            ],\n          },\n        ],\n      }),\n    });\n\n    const data = await response.json() as {\n      content?: Array<{ text?: string }>;\n    };\n\n    return data.content?.[0]?.text || alt || 'Unable to describe image';\n  }\n}\n", "import { homedir } from 'node:os';\nimport { join, dirname } from 'node:path';\nimport { existsSync } from 'node:fs';\nimport { fileURLToPath } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n/**\n * Resolve o diret\u00F3rio de dados da knowledge base.\n *\n * Prioridade:\n * 1. Pasta 'data' no diret\u00F3rio do pacote mcp-knowledge (para uso em projeto local)\n * 2. Pasta 'packages/mcp-knowledge/data' relativa ao root (para bundle via npx)\n * 3. ~/.eduzz-mcp (fallback para uso standalone)\n */\nexport function getDataDir(): string {\n  // Caminho relativo ao pacote: packages/mcp-knowledge/data\n  // __dirname ser\u00E1 dist/ ap\u00F3s compila\u00E7\u00E3o, ent\u00E3o subimos 1 n\u00EDvel\n  const projectDataDir = join(__dirname, '..', 'data');\n\n  if (existsSync(projectDataDir)) {\n    return projectDataDir;\n  }\n\n  // Para bundle: __dirname \u00E9 dist/, data est\u00E1 em packages/mcp-knowledge/data\n  const bundledDataDir = join(__dirname, '..', 'packages', 'mcp-knowledge', 'data');\n\n  if (existsSync(bundledDataDir)) {\n    return bundledDataDir;\n  }\n\n  // Fallback para home do usu\u00E1rio\n  return join(homedir(), '.eduzz-mcp');\n}\n\n/**\n * Retorna o caminho para o arquivo de configura\u00E7\u00E3o do usu\u00E1rio.\n * Sempre no home do usu\u00E1rio (credenciais n\u00E3o devem ir para o repo).\n */\nexport function getConfigDir(): string {\n  return join(homedir(), '.eduzz-mcp');\n}\n", "import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport { z } from 'zod';\nimport { homedir } from 'node:os';\nimport { join } from 'node:path';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { ConfigManager } from '@eduzz/mcp-config';\nimport { EduzzAPIClient } from './client.js';\nimport { ToolGenerator } from './generator.js';\nimport { APIClientConfig } from './types.js';\n\nexport interface APIServerConfig {\n  configManager?: ConfigManager;\n}\n\nexport function registerAPITools(server: McpServer, config: APIServerConfig = {}): void {\n  const configManager = config.configManager || new ConfigManager();\n  let currentClient: EduzzAPIClient | null = null;\n  let generatedTools: Map<string, ReturnType<ToolGenerator['generateTools']>[number]> = new Map();\n\n  function getClient(): EduzzAPIClient {\n    const activeProfile = configManager.getActiveProfile();\n    if (!activeProfile) {\n      throw new Error('No active profile. Use eduzz_profile_create to configure credentials.');\n    }\n\n    const clientConfig: APIClientConfig = {\n      apiKey: activeProfile.profile.api_key,\n      apiSecret: activeProfile.profile.api_secret,\n      environment: activeProfile.profile.environment,\n    };\n\n    // Reuse client if config hasn't changed\n    if (currentClient) {\n      return currentClient;\n    }\n\n    currentClient = new EduzzAPIClient(clientConfig);\n    return currentClient;\n  }\n\n  function loadOpenAPISpec(): Record<string, unknown> | null {\n    const specPath = join(homedir(), '.eduzz-mcp', 'raw', 'openapi', 'spec.json');\n\n    if (!existsSync(specPath)) {\n      return null;\n    }\n\n    try {\n      const content = readFileSync(specPath, 'utf-8');\n      const parsed = JSON.parse(content) as { spec?: Record<string, unknown> };\n      return parsed.spec || null;\n    } catch {\n      return null;\n    }\n  }\n\n  function initializeGeneratedTools(): void {\n    const spec = loadOpenAPISpec();\n    if (!spec) {\n      return;\n    }\n\n    try {\n      const client = getClient();\n      const generator = new ToolGenerator(spec, client);\n      generatedTools = generator.generateToolsMap();\n    } catch {\n      // Config might not be set up yet\n    }\n  }\n\n  // Initialize on startup\n  initializeGeneratedTools();\n\n  // Generic API call tool (always available)\n  server.tool(\n    'eduzz_api_call',\n    'Make a generic API call to the Eduzz API',\n    {\n      method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']).describe('HTTP method'),\n      path: z.string().describe('API endpoint path (e.g., \"/invoices\", \"/users/123\")'),\n      query: z.record(z.string()).optional().describe('Query parameters'),\n      body: z.unknown().optional().describe('Request body for POST/PUT/PATCH'),\n      profile: z.string().optional().describe('Profile name to use (defaults to active profile)'),\n    },\n    async ({ method, path, query, body, profile }) => {\n      try {\n        // Switch profile if specified\n        if (profile) {\n          configManager.switchProfile(profile);\n          currentClient = null; // Force new client\n        }\n\n        const client = getClient();\n        const response = await client.request({\n          method,\n          path,\n          query: query as Record<string, string | number | boolean> | undefined,\n          body,\n        });\n\n        if (!response.success) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `API Error: ${response.error?.code} - ${response.error?.message}`,\n              },\n            ],\n            isError: true,\n          };\n        }\n\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(response.data, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    }\n  );\n\n  // List available API endpoints\n  server.tool(\n    'eduzz_api_endpoints',\n    'List available API endpoints from the OpenAPI spec',\n    {\n      filter: z.string().optional().describe('Filter endpoints by path or method'),\n    },\n    async ({ filter }) => {\n      const spec = loadOpenAPISpec() as { paths?: Record<string, Record<string, { summary?: string }>> } | null;\n\n      if (!spec || !spec.paths) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No OpenAPI spec available. Run eduzz_sync from mcp-knowledge to fetch the API documentation.',\n            },\n          ],\n        };\n      }\n\n      const endpoints: string[] = [];\n\n      for (const [path, methods] of Object.entries(spec.paths)) {\n        for (const [method, operation] of Object.entries(methods)) {\n          if (!['get', 'post', 'put', 'patch', 'delete'].includes(method.toLowerCase())) {\n            continue;\n          }\n\n          const op = operation as { summary?: string };\n          const line = `${method.toUpperCase().padEnd(7)} ${path} - ${op.summary || 'No description'}`;\n\n          if (!filter || line.toLowerCase().includes(filter.toLowerCase())) {\n            endpoints.push(line);\n          }\n        }\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: endpoints.length > 0\n              ? `Available API endpoints:\\n\\n${endpoints.join('\\n')}`\n              : 'No endpoints found matching the filter.',\n          },\n        ],\n      };\n    }\n  );\n\n  // Get current profile info\n  server.tool(\n    'eduzz_api_status',\n    'Get the current API configuration status',\n    {},\n    async () => {\n      const activeProfile = configManager.getActiveProfile();\n\n      if (!activeProfile) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: 'No active profile configured. Use eduzz_profile_create to set up credentials.',\n            },\n          ],\n        };\n      }\n\n      const client = getClient();\n      const rateLimit = client.getRateLimitInfo();\n\n      let status = `API Status:\n- Active Profile: ${activeProfile.name}\n- Environment: ${activeProfile.profile.environment}\n- API Key: ${activeProfile.profile.api_key.substring(0, 8)}...`;\n\n      if (rateLimit) {\n        status += `\n- Rate Limit: ${rateLimit.remaining}/${rateLimit.limit}\n- Resets at: ${rateLimit.resetAt.toISOString()}`;\n      }\n\n      const spec = loadOpenAPISpec();\n      if (spec) {\n        status += '\\n- OpenAPI spec: Loaded';\n        status += `\\n- Generated tools: ${generatedTools.size}`;\n      } else {\n        status += '\\n- OpenAPI spec: Not available';\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: status,\n          },\n        ],\n      };\n    }\n  );\n\n  // Reload generated tools\n  server.tool(\n    'eduzz_api_reload',\n    'Reload the API tools from the OpenAPI spec',\n    {},\n    async () => {\n      currentClient = null;\n      initializeGeneratedTools();\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Reloaded ${generatedTools.size} API tools from OpenAPI spec.`,\n          },\n        ],\n      };\n    }\n  );\n\n  // Register generated tools dynamically\n  // Note: In a real implementation, you'd need to restart the server\n  // or use a dynamic tool registration mechanism\n  for (const [name, tool] of generatedTools) {\n    server.tool(\n      name,\n      tool.description,\n      tool.inputSchema instanceof z.ZodObject\n        ? (tool.inputSchema as z.ZodObject<Record<string, z.ZodType>>).shape\n        : {},\n      async (params) => {\n        try {\n          const result = await tool.handler(params);\n          return {\n            content: [\n              {\n                type: 'text',\n                text: JSON.stringify(result, null, 2),\n              },\n            ],\n          };\n        } catch (error) {\n          return {\n            content: [\n              {\n                type: 'text',\n                text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n              },\n            ],\n            isError: true,\n          };\n        }\n      }\n    );\n  }\n\n}\n\nexport function createAPIServer(config: APIServerConfig = {}): McpServer {\n  const server = new McpServer({\n    name: 'eduzz-api',\n    version: '1.0.0',\n  });\n  registerAPITools(server, config);\n  return server;\n}\n\nexport async function startServer(config: APIServerConfig = {}): Promise<void> {\n  const server = createAPIServer(config);\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n}\n", "import { createHmac } from 'node:crypto';\nimport {\n  APIClientConfig,\n  APIResponse,\n  APIError,\n  RequestOptions,\n  BASE_URLS,\n  RateLimitInfo,\n} from './types.js';\n\nexport class EduzzAPIClient {\n  private config: Required<APIClientConfig>;\n  private rateLimitInfo: RateLimitInfo | null = null;\n\n  constructor(config: APIClientConfig) {\n    this.config = {\n      timeout: 30000,\n      retryAttempts: 3,\n      retryDelay: 1000,\n      ...config,\n    };\n  }\n\n  private getBaseUrl(): string {\n    return BASE_URLS[this.config.environment];\n  }\n\n  private generateSignature(timestamp: string, body: string): string {\n    const payload = `${timestamp}${body}`;\n    return createHmac('sha256', this.config.apiSecret)\n      .update(payload)\n      .digest('hex');\n  }\n\n  private buildUrl(path: string, query?: Record<string, string | number | boolean | undefined>): string {\n    const url = new URL(path, this.getBaseUrl());\n\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        if (value !== undefined) {\n          url.searchParams.set(key, String(value));\n        }\n      }\n    }\n\n    return url.toString();\n  }\n\n  private parseRateLimitHeaders(headers: Headers): void {\n    const remaining = headers.get('x-ratelimit-remaining');\n    const limit = headers.get('x-ratelimit-limit');\n    const reset = headers.get('x-ratelimit-reset');\n\n    if (remaining && limit) {\n      this.rateLimitInfo = {\n        remaining: parseInt(remaining, 10),\n        limit: parseInt(limit, 10),\n        resetAt: reset ? new Date(parseInt(reset, 10) * 1000) : new Date(),\n      };\n    }\n  }\n\n  getRateLimitInfo(): RateLimitInfo | null {\n    return this.rateLimitInfo;\n  }\n\n  async request<T = unknown>(options: RequestOptions): Promise<APIResponse<T>> {\n    const { method, path, query, body, headers: customHeaders } = options;\n\n    const url = this.buildUrl(path, query);\n    const timestamp = Math.floor(Date.now() / 1000).toString();\n    const bodyString = body ? JSON.stringify(body) : '';\n    const signature = this.generateSignature(timestamp, bodyString);\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n      'X-Api-Key': this.config.apiKey,\n      'X-Api-Timestamp': timestamp,\n      'X-Api-Signature': signature,\n      ...customHeaders,\n    };\n\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < this.config.retryAttempts; attempt++) {\n      try {\n        // Check rate limit\n        if (this.rateLimitInfo && this.rateLimitInfo.remaining <= 0) {\n          const waitTime = this.rateLimitInfo.resetAt.getTime() - Date.now();\n          if (waitTime > 0) {\n            await this.delay(Math.min(waitTime, 60000)); // Max 1 minute wait\n          }\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n        const response = await fetch(url, {\n          method,\n          headers,\n          body: bodyString || undefined,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        this.parseRateLimitHeaders(response.headers);\n\n        const responseHeaders: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          responseHeaders[key] = value;\n        });\n\n        if (!response.ok) {\n          let errorData: APIError;\n\n          try {\n            const errorBody = await response.json() as { code?: string; message?: string; details?: unknown };\n            errorData = {\n              code: errorBody.code || `HTTP_${response.status}`,\n              message: errorBody.message || response.statusText,\n              details: errorBody.details,\n            };\n          } catch {\n            errorData = {\n              code: `HTTP_${response.status}`,\n              message: response.statusText,\n            };\n          }\n\n          // Retry on 5xx errors or rate limiting\n          if (response.status >= 500 || response.status === 429) {\n            lastError = new Error(errorData.message);\n\n            if (attempt < this.config.retryAttempts - 1) {\n              const delay = this.config.retryDelay * Math.pow(2, attempt);\n              await this.delay(delay);\n              continue;\n            }\n          }\n\n          return {\n            success: false,\n            error: errorData,\n            statusCode: response.status,\n            headers: responseHeaders,\n          };\n        }\n\n        const data = await response.json() as T;\n\n        return {\n          success: true,\n          data,\n          statusCode: response.status,\n          headers: responseHeaders,\n        };\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n\n        if (attempt < this.config.retryAttempts - 1) {\n          const delay = this.config.retryDelay * Math.pow(2, attempt);\n          await this.delay(delay);\n        }\n      }\n    }\n\n    return {\n      success: false,\n      error: {\n        code: 'REQUEST_FAILED',\n        message: lastError?.message || 'Request failed after retries',\n      },\n      statusCode: 0,\n      headers: {},\n    };\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  // Convenience methods\n  async get<T = unknown>(\n    path: string,\n    query?: Record<string, string | number | boolean | undefined>\n  ): Promise<APIResponse<T>> {\n    return this.request<T>({ method: 'GET', path, query });\n  }\n\n  async post<T = unknown>(path: string, body?: unknown): Promise<APIResponse<T>> {\n    return this.request<T>({ method: 'POST', path, body });\n  }\n\n  async put<T = unknown>(path: string, body?: unknown): Promise<APIResponse<T>> {\n    return this.request<T>({ method: 'PUT', path, body });\n  }\n\n  async patch<T = unknown>(path: string, body?: unknown): Promise<APIResponse<T>> {\n    return this.request<T>({ method: 'PATCH', path, body });\n  }\n\n  async delete<T = unknown>(path: string): Promise<APIResponse<T>> {\n    return this.request<T>({ method: 'DELETE', path });\n  }\n}\n", "import { z } from 'zod';\n\nexport interface APIClientConfig {\n  apiKey: string;\n  apiSecret: string;\n  environment: 'sandbox' | 'production';\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n}\n\nexport interface APIResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: APIError;\n  statusCode: number;\n  headers: Record<string, string>;\n}\n\nexport interface APIError {\n  code: string;\n  message: string;\n  details?: unknown;\n}\n\nexport interface RequestOptions {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  path: string;\n  query?: Record<string, string | number | boolean | undefined>;\n  body?: unknown;\n  headers?: Record<string, string>;\n}\n\nexport interface GeneratedTool {\n  name: string;\n  description: string;\n  inputSchema: z.ZodType;\n  handler: (params: unknown) => Promise<unknown>;\n}\n\nexport const BASE_URLS = {\n  sandbox: 'https://api-sandbox.eduzz.com',\n  production: 'https://api.eduzz.com',\n} as const;\n\nexport interface RateLimitInfo {\n  remaining: number;\n  limit: number;\n  resetAt: Date;\n}\n", "import { z } from 'zod';\nimport { GeneratedTool } from './types.js';\nimport { EduzzAPIClient } from './client.js';\n\ninterface OpenAPISpec {\n  paths?: Record<string, Record<string, PathOperation>>;\n  components?: {\n    schemas?: Record<string, SchemaObject>;\n  };\n}\n\ninterface PathOperation {\n  operationId?: string;\n  summary?: string;\n  description?: string;\n  tags?: string[];\n  parameters?: ParameterObject[];\n  requestBody?: RequestBodyObject;\n  responses?: Record<string, ResponseObject>;\n}\n\ninterface ParameterObject {\n  name: string;\n  in: 'query' | 'path' | 'header' | 'cookie';\n  description?: string;\n  required?: boolean;\n  schema?: SchemaObject;\n}\n\ninterface RequestBodyObject {\n  description?: string;\n  required?: boolean;\n  content?: Record<string, MediaTypeObject>;\n}\n\ninterface MediaTypeObject {\n  schema?: SchemaObject;\n}\n\ninterface ResponseObject {\n  description?: string;\n  content?: Record<string, MediaTypeObject>;\n}\n\ninterface SchemaObject {\n  type?: string;\n  format?: string;\n  items?: SchemaObject;\n  properties?: Record<string, SchemaObject>;\n  required?: string[];\n  enum?: unknown[];\n  description?: string;\n  $ref?: string;\n}\n\nexport class ToolGenerator {\n  private spec: OpenAPISpec;\n  private client: EduzzAPIClient;\n\n  constructor(spec: OpenAPISpec, client: EduzzAPIClient) {\n    this.spec = spec;\n    this.client = client;\n  }\n\n  private schemaToZod(schema: SchemaObject | undefined): z.ZodType {\n    if (!schema) {\n      return z.unknown();\n    }\n\n    if (schema.$ref) {\n      const refPath = schema.$ref.split('/');\n      const schemaName = refPath[refPath.length - 1];\n      const refSchema = this.spec.components?.schemas?.[schemaName];\n      return this.schemaToZod(refSchema);\n    }\n\n    switch (schema.type) {\n      case 'string':\n        if (schema.enum) {\n          return z.enum(schema.enum as [string, ...string[]]);\n        }\n        if (schema.format === 'date') {\n          return z.string().describe(schema.description || 'Date string');\n        }\n        if (schema.format === 'date-time') {\n          return z.string().describe(schema.description || 'ISO 8601 datetime');\n        }\n        if (schema.format === 'email') {\n          return z.string().email().describe(schema.description || 'Email address');\n        }\n        return z.string().describe(schema.description || '');\n\n      case 'integer':\n      case 'number':\n        return z.number().describe(schema.description || '');\n\n      case 'boolean':\n        return z.boolean().describe(schema.description || '');\n\n      case 'array':\n        return z.array(this.schemaToZod(schema.items)).describe(schema.description || '');\n\n      case 'object':\n        if (!schema.properties) {\n          return z.record(z.unknown()).describe(schema.description || '');\n        }\n\n        const shape: Record<string, z.ZodType> = {};\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n          const isRequired = schema.required?.includes(key);\n          let zodType = this.schemaToZod(propSchema);\n\n          if (!isRequired) {\n            zodType = zodType.optional();\n          }\n\n          shape[key] = zodType;\n        }\n        return z.object(shape).describe(schema.description || '');\n\n      default:\n        return z.unknown();\n    }\n  }\n\n  private generateToolName(method: string, path: string, operationId?: string): string {\n    if (operationId) {\n      // Convert operationId to snake_case\n      return `eduzz_${operationId\n        .replace(/([a-z])([A-Z])/g, '$1_$2')\n        .toLowerCase()\n        .replace(/[^a-z0-9_]/g, '_')}`;\n    }\n\n    // Generate from path\n    const cleanPath = path\n      .replace(/^\\//, '')\n      .replace(/\\{[^}]+\\}/g, '')\n      .replace(/\\//g, '_')\n      .replace(/[^a-z0-9_]/gi, '')\n      .toLowerCase();\n\n    return `eduzz_${cleanPath}_${method.toLowerCase()}`;\n  }\n\n  private buildInputSchema(\n    parameters: ParameterObject[],\n    requestBody?: RequestBodyObject\n  ): z.ZodObject<Record<string, z.ZodType>> {\n    const shape: Record<string, z.ZodType> = {};\n\n    // Add path/query parameters\n    for (const param of parameters) {\n      if (param.in === 'path' || param.in === 'query') {\n        let zodType = this.schemaToZod(param.schema);\n\n        if (param.description) {\n          zodType = zodType.describe(param.description);\n        }\n\n        if (!param.required) {\n          zodType = zodType.optional();\n        }\n\n        shape[param.name] = zodType;\n      }\n    }\n\n    // Add request body\n    if (requestBody) {\n      const jsonContent = requestBody.content?.['application/json'];\n      if (jsonContent?.schema) {\n        const bodySchema = this.schemaToZod(jsonContent.schema);\n        if (!requestBody.required) {\n          shape.body = bodySchema.optional();\n        } else {\n          shape.body = bodySchema;\n        }\n      }\n    }\n\n    return z.object(shape);\n  }\n\n  generateTools(): GeneratedTool[] {\n    const tools: GeneratedTool[] = [];\n\n    if (!this.spec.paths) {\n      return tools;\n    }\n\n    for (const [path, methods] of Object.entries(this.spec.paths)) {\n      for (const [method, operation] of Object.entries(methods)) {\n        if (!['get', 'post', 'put', 'patch', 'delete'].includes(method.toLowerCase())) {\n          continue;\n        }\n\n        const op = operation as PathOperation;\n        const toolName = this.generateToolName(method, path, op.operationId);\n        const description = op.summary || op.description || `${method.toUpperCase()} ${path}`;\n        const inputSchema = this.buildInputSchema(op.parameters || [], op.requestBody);\n\n        const tool: GeneratedTool = {\n          name: toolName,\n          description,\n          inputSchema,\n          handler: async (params: unknown) => {\n            const typedParams = params as Record<string, unknown>;\n\n            // Build path with parameters\n            let finalPath = path;\n            const queryParams: Record<string, string | number | boolean> = {};\n\n            for (const param of op.parameters || []) {\n              const value = typedParams[param.name];\n              if (value !== undefined) {\n                if (param.in === 'path') {\n                  finalPath = finalPath.replace(`{${param.name}}`, String(value));\n                } else if (param.in === 'query') {\n                  queryParams[param.name] = value as string | number | boolean;\n                }\n              }\n            }\n\n            const response = await this.client.request({\n              method: method.toUpperCase() as 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',\n              path: finalPath,\n              query: Object.keys(queryParams).length > 0 ? queryParams : undefined,\n              body: typedParams.body,\n            });\n\n            return response;\n          },\n        };\n\n        tools.push(tool);\n      }\n    }\n\n    return tools;\n  }\n\n  generateToolsMap(): Map<string, GeneratedTool> {\n    const tools = this.generateTools();\n    return new Map(tools.map((t) => [t.name, t]));\n  }\n}\n"],
  "mappings": "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",
  "names": ["McpServer", "StdioServerTransport", "z", "z", "McpServer", "StdioServerTransport", "z", "join", "existsSync", "readFileSync", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "join", "readFileSync", "writeFileSync", "existsSync", "join", "existsSync", "mkdirSync", "join", "existsSync", "mkdirSync", "writeFileSync", "join", "createHash", "z", "join", "existsSync", "mkdirSync", "createHash", "writeFileSync", "TurndownService", "readFileSync", "writeFileSync", "existsSync", "mkdirSync", "title", "description", "dir", "createHash", "homedir", "join", "dirname", "existsSync", "existsSync", "mkdirSync", "join", "createHash", "z", "join", "existsSync", "readFileSync", "McpServer", "StdioServerTransport", "z", "homedir", "join", "existsSync", "readFileSync", "z", "join", "homedir", "existsSync", "readFileSync", "z", "McpServer", "startServer", "StdioServerTransport"]
}
